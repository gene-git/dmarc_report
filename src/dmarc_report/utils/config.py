# SPGDX-License-Identifier: MIT
# SPDX-FileCopyrightText: © 2023-present Gene C <arch@sapience.com>
"""
Read options from config files:
    1) /etc/dmarc_report/config
    2) ~/.config/dmarc_options/config
"""
from typing import (Any)
import os
from datetime import datetime
from pathlib import Path
import tomli_w
from .toml import read_toml_file
from .tools import merge_dict


def read_config() -> dict[str, Any]:
    """
    Read any config settings.

    - Configs read and merged in order:
      - /etc/dmarc_report/config
      - ~/.config/dmarc_report/config
    - v1 configs are converted to v2 configs and saved back if permitted
    """
    conf_sys_v2 = _read_config_v2('sys')
    conf_user_v2 = _read_config_v2('user')
    config = merge_dict(conf_sys_v2, conf_user_v2)

    return config


def _read_config_v2(which: str):
    """
    Read 1 config file.

    - which == 'sys' read /etc/dmarc_report/config
    - which == 'user' read ~/.config/dmarc_report/config
      - ~/.config/dmarc_report/config
    """
    config = None
    home = str(Path.home())
    tool = 'dmarc_report'
    v2_file = 'config.v2'
    conf_dir = f'/etc/{tool}' if which == 'sys' else f'{home}/.config/{tool}'
    v2_path = f'{conf_dir}/{v2_file}'

    #
    # Try v2 config
    if os.path.exists(v2_path) and os.access(v2_path, os.R_OK):
        config = read_toml_file(v2_path)
        return config

    #
    # No v2 = try for version 1 configs
    # merge v1 configs into v2 config
    #
    v1_dmarc = 'config'
    v1_tls = 'tls-config'
    v1_dmarc_path = f'{conf_dir}/{v1_dmarc}'
    v1_tls_path = f'{conf_dir}/{v1_tls}'
    config_dmarc = _read_configs_v1(v1_dmarc_path)
    config_tls = _read_configs_v1(v1_tls_path)

    config = _convert_v1_v2(config_dmarc, config_tls)
    if config:
        print(' Converting version 1 configs to version 2')
        okay = _save_config_v2(config, v2_path)
        if not okay and which == 'sys':
            v2_path_alt = f'{home}/.config/{tool}/config.v2.system'
            print(f'Error saving version 2 config file: {v2_path}')
            print(f'    saving as {v2_path_alt}')
            okay = _save_config_v2(config, v2_path_alt)
            if okay:
                print(f' New version 2 config saved in: {v2_path_alt}')
                print(f' Please install in: {v2_path}')
            else:
                print(f' Error saving version 2 config {v2_path_alt}')
        elif okay:
            print(f' New version 2 config saved in: {v2_path}')
        else:
            print(f' Error saving version 2 config {v2_path}')

    return config


def _read_configs_v1(fpath: str) -> dict[str, Any]:
    """
    Read version 1 config from fpath.
    """
    v1_config: dict[str, Any] = {}
    if os.path.exists(fpath) and os.access(fpath, os.R_OK):
        v1_config = read_toml_file(fpath)
    return v1_config


def _convert_v1_v2(dmarc: dict[str, str], tls: dict[str, str]):
    '''
    Merge version 1 dmarc and tls config into v2 config
    '''
    if not dmarc and not tls:
        return None

    glob = {}
    keys_shared = []
    if dmarc:
        for (key, val) in dmarc.items():
            if key in tls and val == tls.get(key):
                keys_shared.append(key)
                glob[key] = val

    for key in keys_shared:
        del dmarc[key]
        del tls[key]

    config = {'global': glob,
              'dmarc': dmarc,
              'tls': tls
              }
    return config


def _save_config_v2(config: dict[str, Any], fpath: str) -> bool:
    '''
    Write config to fpath
    returns True if suceeded else False
    '''
    if not config:
        return True

    now = datetime.today()
    now_str = now.strftime("%Y-%m-%d-%H:%M:%S")
    header = '#\n# Version 2 config\n'
    header += f'# Autogenerated at {now_str}\n#\n'

    try:
        with open(fpath, 'wb') as fob:
            fob.write(header.encode())
            tomli_w.dump(config, fob)
        return True
    except OSError as err:
        print(f'Error writing {fpath}: {err}')
        return False
